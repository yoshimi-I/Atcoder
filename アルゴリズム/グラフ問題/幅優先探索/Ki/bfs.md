# 幅優先探索
## 概要
- 幅優先探索とは具体的にグラフを横に広がるように探索することをいう
    - 逆に奥に突き進むように探索する方法を深さ優先探索という
- 詳しくは[グラフ探索とは](https://qiita.com/drken/items/4a7869c5e304883f539b#3-%E6%B7%B1%E3%81%95%E5%84%AA%E5%85%88%E6%8E%A2%E7%B4%A2-dfs-%E3%81%A8%E5%B9%85%E5%84%AA%E5%85%88%E6%8E%A2%E7%B4%A2-bfs)を読んでほしい
- 読んだ上でpyhtonでの実装におけるポイントを解説していく
- また同じ問題を深さ優先探索でも解いていく
## 方針
- 深さ優先探索で必要なことは主に3つ
1. 配列の番号と行き先が格納されている二次元配列
2. スタックを用いたデータの格納庫(dequeを用いる)
3. whileを用いてスタックが空になるまで処理を繰り返す
この二つを持ちいて実装していく
## 手順
1. まずは配列の番号と行き先が格納されている二次元配列を用意する
2. 次に行った場所をチェックする配列を用意する
3. 探索を始める番号をキューの中に入れる
4. キューを取り出し、処理を開始
5. 取り出した値の行き先をキューに格納
6. キューを取り出し処理を再開
## イメージ
- キューを使うとなぜ幅優先探索になるのかというと、チーム対抗のクイズゲームを想像してほしい
- 例えば1チームそれぞれ3人いたとして、A,B,Cチームだとする。
1. まずAの一人目がクイズの解答を行う、その時後ろにはB,Cの最初の回答者が並んでいる。
2. Aが答え終わるとAの次のメンバーが答えを言いに行くが前にはBとCの1人目の人が並んでいるという状態である
3. そうするとA,B,C,A,B,C,と行ったように横に広がるような解答が行われる
4. キューはFIFO(最初に並んでいた人優先)の考え方よりこのようにキューを用いることで実装できる

## なぜキューを用いるのか
- 今回はFIFOの原理に基づくので([0]から取り出していくので)実行時間的にもキューが最も適している
    - というか配列で律儀にやると時間が間に合わない
    - 先入先出なのでdequeを使うくらいの概念で十分である
## まとめ
- とは言っても結局は慣れるしかないのでコードをたくさん書くしかない
- 幅優先探索 = キューを用いる
- 深さ優先探索 = 再起関数を用いる
