# bit全探索
## 説明
- bit全探索とは「n 個の選択肢それぞれに Yes or No の二択があるが、選択肢を全てを網羅的にチェックしたい」といった場合に使える。
- 当たり前だが、Yes or No の二択が n 箇所あるので、パターン数は 2^n になる。（何も選ばないという選択肢もパターンに含まれる）
- そこでYesを数字の1で、Noを数字の0で、1と0のみで作られた数字で表記することで選んだのか、選んでないのかの判別を行う。
- やっていることは単なる全探索。
## 例題
- みかん（100円）りんご（200円）ぶどう（300円）がそれぞれ1つずつ果物屋さんにありました。財布の中には300円ありますが、考え得るすべての買い物パターンを列挙しなさい。
## ヒント
- 例えば今回であれば買う場合を"1",買わない場合を"0"とする
    - 今回左から順にみかん、りんご、ぶどうを買うかどうかの配列であるとすると,101という数字を受け取った場合、最初が1であるのでみかんを購入、次が0よりりんごは買わず、最後は1よりぶどうは購入という意味となる。
```
3桁の1と0で作られた数字を羅列すると、
[[000],[001],[010],[011]....[111]]
となる

[000]は"何も購入していない"を意味する
[101]はみかんとぶどうを購入を意味する
```
- このように買う、買わないの2択であるので0と1のみを用いた数字の羅列を用いて表現できる。
    - 1と0のみを用いた数字の羅列 --> 2進法特有の解答を用いる
## 解答例
```
money = 300
item = (("みかん", 100), ("りんご", 200), ("ぶどう", 300))
n = len(item)
for i in range(2 ** n):
    bag = []
    total = 0
    for j in range(n):  # このループが一番のポイント
        if ((i >> j) & 1):  
        # 順に右にシフトさせ最下位bitのチェックを行う
            bag.append(item[j][0])  
            # フラグが立っていたら bag に果物を詰める
            total += item[j][1]  
            # 買い物累計額にも加算
    if (total <= money):
        print(total, bag)
```
## 解説
```
for i in range(2 ** n):
```
- みかん、りんご、ぶどう全てに買うか買わないの2択が存在する。そのため試行回数は(2 ** n)となる。
    
    - 1と0の数字の羅列は全部で(2 ** n)通り
```
for j in range(n):
```
- みかん、りんご、ぶどうの3種類あるので、その数処理を繰り返し、どの果物が含まれているかの判別を行う。
    - 100の位がみかん、10の位がりんご、1の位がみかんより3回位を確認する作業が必要である。
```
if ((i >> j) & 1):
```
- i >> jの意味はiの数字の位をjだけ下げるという意味である。
    - 例えばi = 5,j = 2の時
    - つまり、5であれば2進数表記は101であり、これを2回ずらすと1となる
        - これは5の100の位が１であることを示している
        - つまり、100の位は2つずらした時に、その値が1と一致するのかどうかで判断することができるということである。
- またこの時、特にbinを用いて2進数に変換する必要はない、>>を用いることで自動的に2進数に変換されるからである。
## 具体例
```
print(5 >> 2)
>>> 1

i = 5
print(bin(i))
>>>'0b101'  
# 5 を 2 進数で表記すると 101

print(bin(i >> 2))
>>>'0b1' 
# 5 を 2 回右にシフトすると 001

print((i >> 2) == 1)
>>>true
# 5 を 2 回右にシフトしたものと 1 の論理積は 1 (=True)
```
## ポイント
- 当たり前ではあるが1つ目のfor文と2つ目のfor文では
```
for i in range(2 ** n):
for j in range(n): 
```
と必ずこの形になる。
