# 編集距離問題

## 問題
- [編集距離](https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/1/DPL_1_E)

## 解答
```
s1 = input()
s2 = input()
s1_num = len(s1)
s2_num = len(s2)

DP = list(([100] * (s1_num + 1)) for _ in range(s2_num + 1) )
for a in range(s1_num + 1):
    DP[0][a] = a
for b in range(s2_num + 1) :
    DP[b][0] = b
for i in range(1,s2_num + 1):
    for j in range(1,s1_num + 1):
        if s1[j-1] == s2[i-1]:
            DP[i][j] = DP[i-1][j-1]
        else:
            DP[i][j] = min(DP[i-1][j-1],DP[i-1][j],DP[i][j-1]) + 1
print(DP[s2_num][s1_num])

```
## 解説
- DPの配列を考えたとき、ある四隅を囲ってほしい
```
n(1)  n1(2)

n1(3)  n(4)
```
- 今回一致されたい文字列をa,bとする。
- 左上から順に1,2,3,4と番号をつけると重要なのは1,2,3番のものはa,bが必ず一致しているということである
    - つまりは編集を終えて、a,b一を一致させるための処理を終えそのコストを既に保持している状態であるということである
- そしてaの文字列とbの文字列を1番目から比較していく
- では一致しなかったらどうするかと言うと１,2,3番の中の最小値に+1下値を4の値とすればいいことになる。
    - 例えば3→4,2→4の時は1の時点で数が１つ増えているためどちらかに文字を追加しなくてはいけず絶対にコストがかかってしまう
    - 逆に１→3の場合はどちらも文字が増えているためコスト0という可能性があり得ているのである。
- 逆に一致したら１→4で値を引き継げばいいだけのことである
    - aもbも数が増えているかつ同じ文字が入ったのでコストはゼロであると容易に想像できると思う